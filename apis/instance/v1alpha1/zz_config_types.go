// SPDX-FileCopyrightText: 2023 The Crossplane Authors <https://crossplane.io>
//
// SPDX-License-Identifier: Apache-2.0

/*
Copyright 2022 Upbound Inc.
*/

// Code generated by upjet. DO NOT EDIT.

package v1alpha1

import (
	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
	"k8s.io/apimachinery/pkg/runtime/schema"

	v1 "github.com/crossplane/crossplane-runtime/apis/common/v1"
)

type ConfigDevicesInitParameters struct {

	// The SDA-SDH slots, represent the Linux block device nodes for the first 8 disks attached to the Linode.  Each device must be suplied sequentially.  The device can be either a Disk or a Volume identified by disk_id or volume_id. Only one disk identifier is permitted per slot. Devices mapped from sde through sdh are unavailable in "fullvirt" virt_mode.
	// Device can be either a Disk or Volume identified by disk_id or volume_id. Only one type per slot allowed.
	Sda []DevicesSdaInitParameters `json:"sda,omitempty" tf:"sda,omitempty"`

	// Device can be either a Disk or Volume identified by disk_id or volume_id. Only one type per slot allowed.
	Sdb []DevicesSdbInitParameters `json:"sdb,omitempty" tf:"sdb,omitempty"`

	// Device can be either a Disk or Volume identified by disk_id or volume_id. Only one type per slot allowed.
	Sdc []DevicesSdcInitParameters `json:"sdc,omitempty" tf:"sdc,omitempty"`

	// Device can be either a Disk or Volume identified by disk_id or volume_id. Only one type per slot allowed.
	Sdd []DevicesSddInitParameters `json:"sdd,omitempty" tf:"sdd,omitempty"`

	// Device can be either a Disk or Volume identified by disk_id or volume_id. Only one type per slot allowed.
	Sde []DevicesSdeInitParameters `json:"sde,omitempty" tf:"sde,omitempty"`

	// Device can be either a Disk or Volume identified by disk_id or volume_id. Only one type per slot allowed.
	Sdf []DevicesSdfInitParameters `json:"sdf,omitempty" tf:"sdf,omitempty"`

	// Device can be either a Disk or Volume identified by disk_id or volume_id. Only one type per slot allowed.
	Sdg []DevicesSdgInitParameters `json:"sdg,omitempty" tf:"sdg,omitempty"`

	// Device can be either a Disk or Volume identified by disk_id or volume_id. Only one type per slot allowed.
	Sdh []DevicesSdhInitParameters `json:"sdh,omitempty" tf:"sdh,omitempty"`
}

type ConfigDevicesObservation struct {

	// The SDA-SDH slots, represent the Linux block device nodes for the first 8 disks attached to the Linode.  Each device must be suplied sequentially.  The device can be either a Disk or a Volume identified by disk_id or volume_id. Only one disk identifier is permitted per slot. Devices mapped from sde through sdh are unavailable in "fullvirt" virt_mode.
	// Device can be either a Disk or Volume identified by disk_id or volume_id. Only one type per slot allowed.
	Sda []DevicesSdaObservation `json:"sda,omitempty" tf:"sda,omitempty"`

	// Device can be either a Disk or Volume identified by disk_id or volume_id. Only one type per slot allowed.
	Sdb []DevicesSdbObservation `json:"sdb,omitempty" tf:"sdb,omitempty"`

	// Device can be either a Disk or Volume identified by disk_id or volume_id. Only one type per slot allowed.
	Sdc []DevicesSdcObservation `json:"sdc,omitempty" tf:"sdc,omitempty"`

	// Device can be either a Disk or Volume identified by disk_id or volume_id. Only one type per slot allowed.
	Sdd []DevicesSddObservation `json:"sdd,omitempty" tf:"sdd,omitempty"`

	// Device can be either a Disk or Volume identified by disk_id or volume_id. Only one type per slot allowed.
	Sde []DevicesSdeObservation `json:"sde,omitempty" tf:"sde,omitempty"`

	// Device can be either a Disk or Volume identified by disk_id or volume_id. Only one type per slot allowed.
	Sdf []DevicesSdfObservation `json:"sdf,omitempty" tf:"sdf,omitempty"`

	// Device can be either a Disk or Volume identified by disk_id or volume_id. Only one type per slot allowed.
	Sdg []DevicesSdgObservation `json:"sdg,omitempty" tf:"sdg,omitempty"`

	// Device can be either a Disk or Volume identified by disk_id or volume_id. Only one type per slot allowed.
	Sdh []DevicesSdhObservation `json:"sdh,omitempty" tf:"sdh,omitempty"`
}

type ConfigDevicesParameters struct {

	// The SDA-SDH slots, represent the Linux block device nodes for the first 8 disks attached to the Linode.  Each device must be suplied sequentially.  The device can be either a Disk or a Volume identified by disk_id or volume_id. Only one disk identifier is permitted per slot. Devices mapped from sde through sdh are unavailable in "fullvirt" virt_mode.
	// Device can be either a Disk or Volume identified by disk_id or volume_id. Only one type per slot allowed.
	// +kubebuilder:validation:Optional
	Sda []DevicesSdaParameters `json:"sda,omitempty" tf:"sda,omitempty"`

	// Device can be either a Disk or Volume identified by disk_id or volume_id. Only one type per slot allowed.
	// +kubebuilder:validation:Optional
	Sdb []DevicesSdbParameters `json:"sdb,omitempty" tf:"sdb,omitempty"`

	// Device can be either a Disk or Volume identified by disk_id or volume_id. Only one type per slot allowed.
	// +kubebuilder:validation:Optional
	Sdc []DevicesSdcParameters `json:"sdc,omitempty" tf:"sdc,omitempty"`

	// Device can be either a Disk or Volume identified by disk_id or volume_id. Only one type per slot allowed.
	// +kubebuilder:validation:Optional
	Sdd []DevicesSddParameters `json:"sdd,omitempty" tf:"sdd,omitempty"`

	// Device can be either a Disk or Volume identified by disk_id or volume_id. Only one type per slot allowed.
	// +kubebuilder:validation:Optional
	Sde []DevicesSdeParameters `json:"sde,omitempty" tf:"sde,omitempty"`

	// Device can be either a Disk or Volume identified by disk_id or volume_id. Only one type per slot allowed.
	// +kubebuilder:validation:Optional
	Sdf []DevicesSdfParameters `json:"sdf,omitempty" tf:"sdf,omitempty"`

	// Device can be either a Disk or Volume identified by disk_id or volume_id. Only one type per slot allowed.
	// +kubebuilder:validation:Optional
	Sdg []DevicesSdgParameters `json:"sdg,omitempty" tf:"sdg,omitempty"`

	// Device can be either a Disk or Volume identified by disk_id or volume_id. Only one type per slot allowed.
	// +kubebuilder:validation:Optional
	Sdh []DevicesSdhParameters `json:"sdh,omitempty" tf:"sdh,omitempty"`
}

type ConfigHelpersInitParameters struct {

	// Populates the /dev directory early during boot without udev. (default true)
	// Populates the /dev directory early during boot without udev.
	DevtmpfsAutomount *bool `json:"devtmpfsAutomount,omitempty" tf:"devtmpfs_automount,omitempty"`

	// Helps maintain correct inittab/upstart console device. (default true)
	// Helps maintain correct inittab/upstart console device.
	Distro *bool `json:"distro,omitempty" tf:"distro,omitempty"`

	// Creates a modules dependency file for the Kernel you run. (default true)
	// Creates a modules dependency file for the Kernel you run.
	ModulesDep *bool `json:"modulesDep,omitempty" tf:"modules_dep,omitempty"`

	// Automatically configures static networking. (default true)
	// Automatically configures static networking.
	Network *bool `json:"network,omitempty" tf:"network,omitempty"`

	// Disables updatedb cron job to avoid disk thrashing. (default true)
	// Disables updatedb cron job to avoid disk thrashing.
	UpdatedbDisabled *bool `json:"updatedbDisabled,omitempty" tf:"updatedb_disabled,omitempty"`
}

type ConfigHelpersObservation struct {

	// Populates the /dev directory early during boot without udev. (default true)
	// Populates the /dev directory early during boot without udev.
	DevtmpfsAutomount *bool `json:"devtmpfsAutomount,omitempty" tf:"devtmpfs_automount,omitempty"`

	// Helps maintain correct inittab/upstart console device. (default true)
	// Helps maintain correct inittab/upstart console device.
	Distro *bool `json:"distro,omitempty" tf:"distro,omitempty"`

	// Creates a modules dependency file for the Kernel you run. (default true)
	// Creates a modules dependency file for the Kernel you run.
	ModulesDep *bool `json:"modulesDep,omitempty" tf:"modules_dep,omitempty"`

	// Automatically configures static networking. (default true)
	// Automatically configures static networking.
	Network *bool `json:"network,omitempty" tf:"network,omitempty"`

	// Disables updatedb cron job to avoid disk thrashing. (default true)
	// Disables updatedb cron job to avoid disk thrashing.
	UpdatedbDisabled *bool `json:"updatedbDisabled,omitempty" tf:"updatedb_disabled,omitempty"`
}

type ConfigHelpersParameters struct {

	// Populates the /dev directory early during boot without udev. (default true)
	// Populates the /dev directory early during boot without udev.
	// +kubebuilder:validation:Optional
	DevtmpfsAutomount *bool `json:"devtmpfsAutomount,omitempty" tf:"devtmpfs_automount,omitempty"`

	// Helps maintain correct inittab/upstart console device. (default true)
	// Helps maintain correct inittab/upstart console device.
	// +kubebuilder:validation:Optional
	Distro *bool `json:"distro,omitempty" tf:"distro,omitempty"`

	// Creates a modules dependency file for the Kernel you run. (default true)
	// Creates a modules dependency file for the Kernel you run.
	// +kubebuilder:validation:Optional
	ModulesDep *bool `json:"modulesDep,omitempty" tf:"modules_dep,omitempty"`

	// Automatically configures static networking. (default true)
	// Automatically configures static networking.
	// +kubebuilder:validation:Optional
	Network *bool `json:"network,omitempty" tf:"network,omitempty"`

	// Disables updatedb cron job to avoid disk thrashing. (default true)
	// Disables updatedb cron job to avoid disk thrashing.
	// +kubebuilder:validation:Optional
	UpdatedbDisabled *bool `json:"updatedbDisabled,omitempty" tf:"updatedb_disabled,omitempty"`
}

type ConfigInitParameters_2 struct {

	// If true, the Linode will be booted into this config. If another config is booted, the Linode will be rebooted into this config. If false, the Linode will be shutdown only if it is currently booted into this config. If undefined, the config will alter the boot status of the Linode.
	// If true, the Linode will be booted to running state. If false, the Linode will be shutdown. If undefined, no action will be taken.
	Booted *bool `json:"booted,omitempty" tf:"booted,omitempty"`

	// Optional field for arbitrary User comments on this Config.
	// Optional field for arbitrary User comments on this Config.
	Comments *string `json:"comments,omitempty" tf:"comments,omitempty"`

	// Blocks for device disks in a Linode's configuration profile.
	Device []DeviceInitParameters `json:"device,omitempty" tf:"device,omitempty"`

	// A dictionary of device disks to use as a device map in a Linode's configuration profile.
	Devices []ConfigDevicesInitParameters `json:"devices,omitempty" tf:"devices,omitempty"`

	// Helpers enabled when booting to this Linode Config.
	Helpers []ConfigHelpersInitParameters `json:"helpers,omitempty" tf:"helpers,omitempty"`

	// An array of Network Interfaces to add to this Linode's Configuration Profile.
	Interface []ConfigInterfaceInitParameters `json:"interface,omitempty" tf:"interface,omitempty"`

	// A Kernel ID to boot a Linode with. Default is linode/latest-64bit. Examples are linode/latest-64bit, linode/grub2, linode/direct-disk, etc. See all kernels here. Note that this is a paginated API endpoint (docs).
	// A Kernel ID to boot a Linode with. Defaults to “linode/latest-64bit”.
	Kernel *string `json:"kernel,omitempty" tf:"kernel,omitempty"`

	// The Config’s label for display purposes only.
	// The Config's label for display purposes only.
	Label *string `json:"label,omitempty" tf:"label,omitempty"`

	// The ID of the Linode to create this configuration profile under.
	// The ID of the Linode to create this configuration profile under.
	// +crossplane:generate:reference:type=Instance
	LinodeID *float64 `json:"linodeId,omitempty" tf:"linode_id,omitempty"`

	// Reference to a Instance to populate linodeId.
	// +kubebuilder:validation:Optional
	LinodeIDRef *v1.Reference `json:"linodeIdRef,omitempty" tf:"-"`

	// Selector for a Instance to populate linodeId.
	// +kubebuilder:validation:Optional
	LinodeIDSelector *v1.Selector `json:"linodeIdSelector,omitempty" tf:"-"`

	// The memory limit of the Config. Defaults to the total ram of the Linode.
	// The memory limit of the Linode.
	MemoryLimit *float64 `json:"memoryLimit,omitempty" tf:"memory_limit,omitempty"`

	// The root device to boot. (default /dev/sda)
	// The root device to boot. If no value or an invalid value is provided, root device will default to /dev/sda. If the device specified at the root device location is not mounted, the Linode will not boot until a device is mounted.
	RootDevice *string `json:"rootDevice,omitempty" tf:"root_device,omitempty"`

	// Defines the state of your Linode after booting. (default, single, binbash)
	// Defines the state of your Linode after booting.
	RunLevel *string `json:"runLevel,omitempty" tf:"run_level,omitempty"`

	// Controls the virtualization mode. (paravirt, fullvirt)
	// Controls the virtualization mode.
	VirtMode *string `json:"virtMode,omitempty" tf:"virt_mode,omitempty"`
}

type ConfigInterfaceIPv4InitParameters struct {

	// The public IP that will be used for the one-to-one NAT purpose. If this is any, the public IPv4 address assigned to this Linode is used on this interface and will be 1:1 NATted with the VPC IPv4 address.
	// The public IP that will be used for the one-to-one NAT purpose.
	NAT11 *string `json:"nat11,omitempty" tf:"nat_1_1,omitempty"`

	// purpose.
	// The IP from the VPC subnet to use for this interface.
	VPC *string `json:"vpc,omitempty" tf:"vpc,omitempty"`
}

type ConfigInterfaceIPv4Observation struct {

	// The public IP that will be used for the one-to-one NAT purpose. If this is any, the public IPv4 address assigned to this Linode is used on this interface and will be 1:1 NATted with the VPC IPv4 address.
	// The public IP that will be used for the one-to-one NAT purpose.
	NAT11 *string `json:"nat11,omitempty" tf:"nat_1_1,omitempty"`

	// purpose.
	// The IP from the VPC subnet to use for this interface.
	VPC *string `json:"vpc,omitempty" tf:"vpc,omitempty"`
}

type ConfigInterfaceIPv4Parameters struct {

	// The public IP that will be used for the one-to-one NAT purpose. If this is any, the public IPv4 address assigned to this Linode is used on this interface and will be 1:1 NATted with the VPC IPv4 address.
	// The public IP that will be used for the one-to-one NAT purpose.
	// +kubebuilder:validation:Optional
	NAT11 *string `json:"nat11,omitempty" tf:"nat_1_1,omitempty"`

	// purpose.
	// The IP from the VPC subnet to use for this interface.
	// +kubebuilder:validation:Optional
	VPC *string `json:"vpc,omitempty" tf:"vpc,omitempty"`
}

type ConfigInterfaceInitParameters struct {

	// IPv4 CIDR VPC Subnet ranges that are routed to this Interface. IPv6 ranges are also available to select participants in the Beta program.
	// List of VPC IPs or IP ranges inside the VPC subnet.
	IPRanges []*string `json:"ipRanges,omitempty" tf:"ip_ranges,omitempty"`

	// The IPv4 configuration of the VPC interface.This attribute is only allowed for VPC interfaces.
	IPv4 []ConfigInterfaceIPv4InitParameters `json:"ipv4,omitempty" tf:"ipv4,omitempty"`

	// This Network Interface’s private IP address in Classless Inter-Domain Routing (CIDR) notation. (e.g. 10.0.0.1/24) This field is only allowed for interfaces with the vlan purpose.
	// This Network Interface's private IP address in Classless Inter-Domain Routing (CIDR) notation.This attribute is only allowed for VLAN interfaces.
	IpamAddress *string `json:"ipamAddress,omitempty" tf:"ipam_address,omitempty"`

	// The Config’s label for display purposes only.
	// The name of the VALN. This attribute is required for VLAN interfaces. This attribute is only allowed for VLAN interfaces.
	Label *string `json:"label,omitempty" tf:"label,omitempty"`

	// Whether the interface is the primary interface that should have the default route for this Linode. This field is only allowed for interfaces with the public or vpc purpose.
	// Whether the interface is the primary interface that should have the default route for this Linode.
	Primary *bool `json:"primary,omitempty" tf:"primary,omitempty"`

	// The type of interface. (public, vlan, vpc)
	// The type of interface.
	Purpose *string `json:"purpose,omitempty" tf:"purpose,omitempty"`

	// The name of the VPC Subnet to join. This field is only allowed and required for interfaces with the vpc purpose.
	// The ID of the subnet which the VPC interface is connected to.This attribute is required for VPC interfaces.This attribute is only allowed for VPC interfaces.
	SubnetID *float64 `json:"subnetId,omitempty" tf:"subnet_id,omitempty"`
}

type ConfigInterfaceObservation struct {

	// Whether this interface is currently booted and active.
	Active *bool `json:"active,omitempty" tf:"active,omitempty"`

	// The ID of the interface.
	ID *float64 `json:"id,omitempty" tf:"id,omitempty"`

	// IPv4 CIDR VPC Subnet ranges that are routed to this Interface. IPv6 ranges are also available to select participants in the Beta program.
	// List of VPC IPs or IP ranges inside the VPC subnet.
	IPRanges []*string `json:"ipRanges,omitempty" tf:"ip_ranges,omitempty"`

	// The IPv4 configuration of the VPC interface.This attribute is only allowed for VPC interfaces.
	IPv4 []ConfigInterfaceIPv4Observation `json:"ipv4,omitempty" tf:"ipv4,omitempty"`

	// This Network Interface’s private IP address in Classless Inter-Domain Routing (CIDR) notation. (e.g. 10.0.0.1/24) This field is only allowed for interfaces with the vlan purpose.
	// This Network Interface's private IP address in Classless Inter-Domain Routing (CIDR) notation.This attribute is only allowed for VLAN interfaces.
	IpamAddress *string `json:"ipamAddress,omitempty" tf:"ipam_address,omitempty"`

	// The Config’s label for display purposes only.
	// The name of the VALN. This attribute is required for VLAN interfaces. This attribute is only allowed for VLAN interfaces.
	Label *string `json:"label,omitempty" tf:"label,omitempty"`

	// Whether the interface is the primary interface that should have the default route for this Linode. This field is only allowed for interfaces with the public or vpc purpose.
	// Whether the interface is the primary interface that should have the default route for this Linode.
	Primary *bool `json:"primary,omitempty" tf:"primary,omitempty"`

	// The type of interface. (public, vlan, vpc)
	// The type of interface.
	Purpose *string `json:"purpose,omitempty" tf:"purpose,omitempty"`

	// The name of the VPC Subnet to join. This field is only allowed and required for interfaces with the vpc purpose.
	// The ID of the subnet which the VPC interface is connected to.This attribute is required for VPC interfaces.This attribute is only allowed for VPC interfaces.
	SubnetID *float64 `json:"subnetId,omitempty" tf:"subnet_id,omitempty"`

	// The ID of VPC which this interface is attached to.
	// The ID of VPC of the subnet which the VPC interface is connected to.
	VPCID *float64 `json:"vpcId,omitempty" tf:"vpc_id,omitempty"`
}

type ConfigInterfaceParameters struct {

	// IPv4 CIDR VPC Subnet ranges that are routed to this Interface. IPv6 ranges are also available to select participants in the Beta program.
	// List of VPC IPs or IP ranges inside the VPC subnet.
	// +kubebuilder:validation:Optional
	IPRanges []*string `json:"ipRanges,omitempty" tf:"ip_ranges,omitempty"`

	// The IPv4 configuration of the VPC interface.This attribute is only allowed for VPC interfaces.
	// +kubebuilder:validation:Optional
	IPv4 []ConfigInterfaceIPv4Parameters `json:"ipv4,omitempty" tf:"ipv4,omitempty"`

	// This Network Interface’s private IP address in Classless Inter-Domain Routing (CIDR) notation. (e.g. 10.0.0.1/24) This field is only allowed for interfaces with the vlan purpose.
	// This Network Interface's private IP address in Classless Inter-Domain Routing (CIDR) notation.This attribute is only allowed for VLAN interfaces.
	// +kubebuilder:validation:Optional
	IpamAddress *string `json:"ipamAddress,omitempty" tf:"ipam_address,omitempty"`

	// The Config’s label for display purposes only.
	// The name of the VALN. This attribute is required for VLAN interfaces. This attribute is only allowed for VLAN interfaces.
	// +kubebuilder:validation:Optional
	Label *string `json:"label,omitempty" tf:"label,omitempty"`

	// Whether the interface is the primary interface that should have the default route for this Linode. This field is only allowed for interfaces with the public or vpc purpose.
	// Whether the interface is the primary interface that should have the default route for this Linode.
	// +kubebuilder:validation:Optional
	Primary *bool `json:"primary,omitempty" tf:"primary,omitempty"`

	// The type of interface. (public, vlan, vpc)
	// The type of interface.
	// +kubebuilder:validation:Optional
	Purpose *string `json:"purpose" tf:"purpose,omitempty"`

	// The name of the VPC Subnet to join. This field is only allowed and required for interfaces with the vpc purpose.
	// The ID of the subnet which the VPC interface is connected to.This attribute is required for VPC interfaces.This attribute is only allowed for VPC interfaces.
	// +kubebuilder:validation:Optional
	SubnetID *float64 `json:"subnetId,omitempty" tf:"subnet_id,omitempty"`
}

type ConfigObservation_2 struct {

	// If true, the Linode will be booted into this config. If another config is booted, the Linode will be rebooted into this config. If false, the Linode will be shutdown only if it is currently booted into this config. If undefined, the config will alter the boot status of the Linode.
	// If true, the Linode will be booted to running state. If false, the Linode will be shutdown. If undefined, no action will be taken.
	Booted *bool `json:"booted,omitempty" tf:"booted,omitempty"`

	// Optional field for arbitrary User comments on this Config.
	// Optional field for arbitrary User comments on this Config.
	Comments *string `json:"comments,omitempty" tf:"comments,omitempty"`

	// Blocks for device disks in a Linode's configuration profile.
	Device []DeviceObservation `json:"device,omitempty" tf:"device,omitempty"`

	// A dictionary of device disks to use as a device map in a Linode's configuration profile.
	Devices []ConfigDevicesObservation `json:"devices,omitempty" tf:"devices,omitempty"`

	// Helpers enabled when booting to this Linode Config.
	Helpers []ConfigHelpersObservation `json:"helpers,omitempty" tf:"helpers,omitempty"`

	ID *string `json:"id,omitempty" tf:"id,omitempty"`

	// An array of Network Interfaces to add to this Linode's Configuration Profile.
	Interface []ConfigInterfaceObservation `json:"interface,omitempty" tf:"interface,omitempty"`

	// A Kernel ID to boot a Linode with. Default is linode/latest-64bit. Examples are linode/latest-64bit, linode/grub2, linode/direct-disk, etc. See all kernels here. Note that this is a paginated API endpoint (docs).
	// A Kernel ID to boot a Linode with. Defaults to “linode/latest-64bit”.
	Kernel *string `json:"kernel,omitempty" tf:"kernel,omitempty"`

	// The Config’s label for display purposes only.
	// The Config's label for display purposes only.
	Label *string `json:"label,omitempty" tf:"label,omitempty"`

	// The ID of the Linode to create this configuration profile under.
	// The ID of the Linode to create this configuration profile under.
	LinodeID *float64 `json:"linodeId,omitempty" tf:"linode_id,omitempty"`

	// The memory limit of the Config. Defaults to the total ram of the Linode.
	// The memory limit of the Linode.
	MemoryLimit *float64 `json:"memoryLimit,omitempty" tf:"memory_limit,omitempty"`

	// The root device to boot. (default /dev/sda)
	// The root device to boot. If no value or an invalid value is provided, root device will default to /dev/sda. If the device specified at the root device location is not mounted, the Linode will not boot until a device is mounted.
	RootDevice *string `json:"rootDevice,omitempty" tf:"root_device,omitempty"`

	// Defines the state of your Linode after booting. (default, single, binbash)
	// Defines the state of your Linode after booting.
	RunLevel *string `json:"runLevel,omitempty" tf:"run_level,omitempty"`

	// Controls the virtualization mode. (paravirt, fullvirt)
	// Controls the virtualization mode.
	VirtMode *string `json:"virtMode,omitempty" tf:"virt_mode,omitempty"`
}

type ConfigParameters_2 struct {

	// If true, the Linode will be booted into this config. If another config is booted, the Linode will be rebooted into this config. If false, the Linode will be shutdown only if it is currently booted into this config. If undefined, the config will alter the boot status of the Linode.
	// If true, the Linode will be booted to running state. If false, the Linode will be shutdown. If undefined, no action will be taken.
	// +kubebuilder:validation:Optional
	Booted *bool `json:"booted,omitempty" tf:"booted,omitempty"`

	// Optional field for arbitrary User comments on this Config.
	// Optional field for arbitrary User comments on this Config.
	// +kubebuilder:validation:Optional
	Comments *string `json:"comments,omitempty" tf:"comments,omitempty"`

	// Blocks for device disks in a Linode's configuration profile.
	// +kubebuilder:validation:Optional
	Device []DeviceParameters `json:"device,omitempty" tf:"device,omitempty"`

	// A dictionary of device disks to use as a device map in a Linode's configuration profile.
	// +kubebuilder:validation:Optional
	Devices []ConfigDevicesParameters `json:"devices,omitempty" tf:"devices,omitempty"`

	// Helpers enabled when booting to this Linode Config.
	// +kubebuilder:validation:Optional
	Helpers []ConfigHelpersParameters `json:"helpers,omitempty" tf:"helpers,omitempty"`

	// An array of Network Interfaces to add to this Linode's Configuration Profile.
	// +kubebuilder:validation:Optional
	Interface []ConfigInterfaceParameters `json:"interface,omitempty" tf:"interface,omitempty"`

	// A Kernel ID to boot a Linode with. Default is linode/latest-64bit. Examples are linode/latest-64bit, linode/grub2, linode/direct-disk, etc. See all kernels here. Note that this is a paginated API endpoint (docs).
	// A Kernel ID to boot a Linode with. Defaults to “linode/latest-64bit”.
	// +kubebuilder:validation:Optional
	Kernel *string `json:"kernel,omitempty" tf:"kernel,omitempty"`

	// The Config’s label for display purposes only.
	// The Config's label for display purposes only.
	// +kubebuilder:validation:Optional
	Label *string `json:"label,omitempty" tf:"label,omitempty"`

	// The ID of the Linode to create this configuration profile under.
	// The ID of the Linode to create this configuration profile under.
	// +crossplane:generate:reference:type=Instance
	// +kubebuilder:validation:Optional
	LinodeID *float64 `json:"linodeId,omitempty" tf:"linode_id,omitempty"`

	// Reference to a Instance to populate linodeId.
	// +kubebuilder:validation:Optional
	LinodeIDRef *v1.Reference `json:"linodeIdRef,omitempty" tf:"-"`

	// Selector for a Instance to populate linodeId.
	// +kubebuilder:validation:Optional
	LinodeIDSelector *v1.Selector `json:"linodeIdSelector,omitempty" tf:"-"`

	// The memory limit of the Config. Defaults to the total ram of the Linode.
	// The memory limit of the Linode.
	// +kubebuilder:validation:Optional
	MemoryLimit *float64 `json:"memoryLimit,omitempty" tf:"memory_limit,omitempty"`

	// The root device to boot. (default /dev/sda)
	// The root device to boot. If no value or an invalid value is provided, root device will default to /dev/sda. If the device specified at the root device location is not mounted, the Linode will not boot until a device is mounted.
	// +kubebuilder:validation:Optional
	RootDevice *string `json:"rootDevice,omitempty" tf:"root_device,omitempty"`

	// Defines the state of your Linode after booting. (default, single, binbash)
	// Defines the state of your Linode after booting.
	// +kubebuilder:validation:Optional
	RunLevel *string `json:"runLevel,omitempty" tf:"run_level,omitempty"`

	// Controls the virtualization mode. (paravirt, fullvirt)
	// Controls the virtualization mode.
	// +kubebuilder:validation:Optional
	VirtMode *string `json:"virtMode,omitempty" tf:"virt_mode,omitempty"`
}

type DeviceInitParameters struct {

	// The Disk ID to map to this disk slot
	DeviceName *string `json:"deviceName,omitempty" tf:"device_name,omitempty"`

	// The Disk ID to map to this device slot
	// The Disk ID to map to this disk slot
	DiskID *float64 `json:"diskId,omitempty" tf:"disk_id,omitempty"`

	// The Volume ID to map to this device slot.
	// The Block Storage volume ID to map to this disk slot
	VolumeID *float64 `json:"volumeId,omitempty" tf:"volume_id,omitempty"`
}

type DeviceObservation struct {

	// The Disk ID to map to this disk slot
	DeviceName *string `json:"deviceName,omitempty" tf:"device_name,omitempty"`

	// The Disk ID to map to this device slot
	// The Disk ID to map to this disk slot
	DiskID *float64 `json:"diskId,omitempty" tf:"disk_id,omitempty"`

	// The Volume ID to map to this device slot.
	// The Block Storage volume ID to map to this disk slot
	VolumeID *float64 `json:"volumeId,omitempty" tf:"volume_id,omitempty"`
}

type DeviceParameters struct {

	// The Disk ID to map to this disk slot
	// +kubebuilder:validation:Optional
	DeviceName *string `json:"deviceName" tf:"device_name,omitempty"`

	// The Disk ID to map to this device slot
	// The Disk ID to map to this disk slot
	// +kubebuilder:validation:Optional
	DiskID *float64 `json:"diskId,omitempty" tf:"disk_id,omitempty"`

	// The Volume ID to map to this device slot.
	// The Block Storage volume ID to map to this disk slot
	// +kubebuilder:validation:Optional
	VolumeID *float64 `json:"volumeId,omitempty" tf:"volume_id,omitempty"`
}

type DevicesSdaInitParameters struct {

	// The Disk ID to map to this device slot
	// The Disk ID to map to this disk slot
	// +crossplane:generate:reference:type=Disk
	DiskID *float64 `json:"diskId,omitempty" tf:"disk_id,omitempty"`

	// Reference to a Disk to populate diskId.
	// +kubebuilder:validation:Optional
	DiskIDRef *v1.Reference `json:"diskIdRef,omitempty" tf:"-"`

	// Selector for a Disk to populate diskId.
	// +kubebuilder:validation:Optional
	DiskIDSelector *v1.Selector `json:"diskIdSelector,omitempty" tf:"-"`

	// The Volume ID to map to this device slot.
	// The Block Storage volume ID to map to this disk slot
	VolumeID *float64 `json:"volumeId,omitempty" tf:"volume_id,omitempty"`
}

type DevicesSdaObservation struct {

	// The Disk ID to map to this device slot
	// The Disk ID to map to this disk slot
	DiskID *float64 `json:"diskId,omitempty" tf:"disk_id,omitempty"`

	// The Volume ID to map to this device slot.
	// The Block Storage volume ID to map to this disk slot
	VolumeID *float64 `json:"volumeId,omitempty" tf:"volume_id,omitempty"`
}

type DevicesSdaParameters struct {

	// The Disk ID to map to this device slot
	// The Disk ID to map to this disk slot
	// +crossplane:generate:reference:type=Disk
	// +kubebuilder:validation:Optional
	DiskID *float64 `json:"diskId,omitempty" tf:"disk_id,omitempty"`

	// Reference to a Disk to populate diskId.
	// +kubebuilder:validation:Optional
	DiskIDRef *v1.Reference `json:"diskIdRef,omitempty" tf:"-"`

	// Selector for a Disk to populate diskId.
	// +kubebuilder:validation:Optional
	DiskIDSelector *v1.Selector `json:"diskIdSelector,omitempty" tf:"-"`

	// The Volume ID to map to this device slot.
	// The Block Storage volume ID to map to this disk slot
	// +kubebuilder:validation:Optional
	VolumeID *float64 `json:"volumeId,omitempty" tf:"volume_id,omitempty"`
}

type DevicesSdbInitParameters struct {

	// The Disk ID to map to this device slot
	// The Disk ID to map to this disk slot
	// +crossplane:generate:reference:type=Disk
	DiskID *float64 `json:"diskId,omitempty" tf:"disk_id,omitempty"`

	// Reference to a Disk to populate diskId.
	// +kubebuilder:validation:Optional
	DiskIDRef *v1.Reference `json:"diskIdRef,omitempty" tf:"-"`

	// Selector for a Disk to populate diskId.
	// +kubebuilder:validation:Optional
	DiskIDSelector *v1.Selector `json:"diskIdSelector,omitempty" tf:"-"`

	// The Volume ID to map to this device slot.
	// The Block Storage volume ID to map to this disk slot
	VolumeID *float64 `json:"volumeId,omitempty" tf:"volume_id,omitempty"`
}

type DevicesSdbObservation struct {

	// The Disk ID to map to this device slot
	// The Disk ID to map to this disk slot
	DiskID *float64 `json:"diskId,omitempty" tf:"disk_id,omitempty"`

	// The Volume ID to map to this device slot.
	// The Block Storage volume ID to map to this disk slot
	VolumeID *float64 `json:"volumeId,omitempty" tf:"volume_id,omitempty"`
}

type DevicesSdbParameters struct {

	// The Disk ID to map to this device slot
	// The Disk ID to map to this disk slot
	// +crossplane:generate:reference:type=Disk
	// +kubebuilder:validation:Optional
	DiskID *float64 `json:"diskId,omitempty" tf:"disk_id,omitempty"`

	// Reference to a Disk to populate diskId.
	// +kubebuilder:validation:Optional
	DiskIDRef *v1.Reference `json:"diskIdRef,omitempty" tf:"-"`

	// Selector for a Disk to populate diskId.
	// +kubebuilder:validation:Optional
	DiskIDSelector *v1.Selector `json:"diskIdSelector,omitempty" tf:"-"`

	// The Volume ID to map to this device slot.
	// The Block Storage volume ID to map to this disk slot
	// +kubebuilder:validation:Optional
	VolumeID *float64 `json:"volumeId,omitempty" tf:"volume_id,omitempty"`
}

type DevicesSdcInitParameters struct {

	// The Disk ID to map to this device slot
	// The Disk ID to map to this disk slot
	// +crossplane:generate:reference:type=Disk
	DiskID *float64 `json:"diskId,omitempty" tf:"disk_id,omitempty"`

	// Reference to a Disk to populate diskId.
	// +kubebuilder:validation:Optional
	DiskIDRef *v1.Reference `json:"diskIdRef,omitempty" tf:"-"`

	// Selector for a Disk to populate diskId.
	// +kubebuilder:validation:Optional
	DiskIDSelector *v1.Selector `json:"diskIdSelector,omitempty" tf:"-"`

	// The Volume ID to map to this device slot.
	// The Block Storage volume ID to map to this disk slot
	VolumeID *float64 `json:"volumeId,omitempty" tf:"volume_id,omitempty"`
}

type DevicesSdcObservation struct {

	// The Disk ID to map to this device slot
	// The Disk ID to map to this disk slot
	DiskID *float64 `json:"diskId,omitempty" tf:"disk_id,omitempty"`

	// The Volume ID to map to this device slot.
	// The Block Storage volume ID to map to this disk slot
	VolumeID *float64 `json:"volumeId,omitempty" tf:"volume_id,omitempty"`
}

type DevicesSdcParameters struct {

	// The Disk ID to map to this device slot
	// The Disk ID to map to this disk slot
	// +crossplane:generate:reference:type=Disk
	// +kubebuilder:validation:Optional
	DiskID *float64 `json:"diskId,omitempty" tf:"disk_id,omitempty"`

	// Reference to a Disk to populate diskId.
	// +kubebuilder:validation:Optional
	DiskIDRef *v1.Reference `json:"diskIdRef,omitempty" tf:"-"`

	// Selector for a Disk to populate diskId.
	// +kubebuilder:validation:Optional
	DiskIDSelector *v1.Selector `json:"diskIdSelector,omitempty" tf:"-"`

	// The Volume ID to map to this device slot.
	// The Block Storage volume ID to map to this disk slot
	// +kubebuilder:validation:Optional
	VolumeID *float64 `json:"volumeId,omitempty" tf:"volume_id,omitempty"`
}

type DevicesSddInitParameters struct {

	// The Disk ID to map to this device slot
	// The Disk ID to map to this disk slot
	// +crossplane:generate:reference:type=Disk
	DiskID *float64 `json:"diskId,omitempty" tf:"disk_id,omitempty"`

	// Reference to a Disk to populate diskId.
	// +kubebuilder:validation:Optional
	DiskIDRef *v1.Reference `json:"diskIdRef,omitempty" tf:"-"`

	// Selector for a Disk to populate diskId.
	// +kubebuilder:validation:Optional
	DiskIDSelector *v1.Selector `json:"diskIdSelector,omitempty" tf:"-"`

	// The Volume ID to map to this device slot.
	// The Block Storage volume ID to map to this disk slot
	VolumeID *float64 `json:"volumeId,omitempty" tf:"volume_id,omitempty"`
}

type DevicesSddObservation struct {

	// The Disk ID to map to this device slot
	// The Disk ID to map to this disk slot
	DiskID *float64 `json:"diskId,omitempty" tf:"disk_id,omitempty"`

	// The Volume ID to map to this device slot.
	// The Block Storage volume ID to map to this disk slot
	VolumeID *float64 `json:"volumeId,omitempty" tf:"volume_id,omitempty"`
}

type DevicesSddParameters struct {

	// The Disk ID to map to this device slot
	// The Disk ID to map to this disk slot
	// +crossplane:generate:reference:type=Disk
	// +kubebuilder:validation:Optional
	DiskID *float64 `json:"diskId,omitempty" tf:"disk_id,omitempty"`

	// Reference to a Disk to populate diskId.
	// +kubebuilder:validation:Optional
	DiskIDRef *v1.Reference `json:"diskIdRef,omitempty" tf:"-"`

	// Selector for a Disk to populate diskId.
	// +kubebuilder:validation:Optional
	DiskIDSelector *v1.Selector `json:"diskIdSelector,omitempty" tf:"-"`

	// The Volume ID to map to this device slot.
	// The Block Storage volume ID to map to this disk slot
	// +kubebuilder:validation:Optional
	VolumeID *float64 `json:"volumeId,omitempty" tf:"volume_id,omitempty"`
}

type DevicesSdeInitParameters struct {

	// The Disk ID to map to this device slot
	// The Disk ID to map to this disk slot
	// +crossplane:generate:reference:type=Disk
	DiskID *float64 `json:"diskId,omitempty" tf:"disk_id,omitempty"`

	// Reference to a Disk to populate diskId.
	// +kubebuilder:validation:Optional
	DiskIDRef *v1.Reference `json:"diskIdRef,omitempty" tf:"-"`

	// Selector for a Disk to populate diskId.
	// +kubebuilder:validation:Optional
	DiskIDSelector *v1.Selector `json:"diskIdSelector,omitempty" tf:"-"`

	// The Volume ID to map to this device slot.
	// The Block Storage volume ID to map to this disk slot
	VolumeID *float64 `json:"volumeId,omitempty" tf:"volume_id,omitempty"`
}

type DevicesSdeObservation struct {

	// The Disk ID to map to this device slot
	// The Disk ID to map to this disk slot
	DiskID *float64 `json:"diskId,omitempty" tf:"disk_id,omitempty"`

	// The Volume ID to map to this device slot.
	// The Block Storage volume ID to map to this disk slot
	VolumeID *float64 `json:"volumeId,omitempty" tf:"volume_id,omitempty"`
}

type DevicesSdeParameters struct {

	// The Disk ID to map to this device slot
	// The Disk ID to map to this disk slot
	// +crossplane:generate:reference:type=Disk
	// +kubebuilder:validation:Optional
	DiskID *float64 `json:"diskId,omitempty" tf:"disk_id,omitempty"`

	// Reference to a Disk to populate diskId.
	// +kubebuilder:validation:Optional
	DiskIDRef *v1.Reference `json:"diskIdRef,omitempty" tf:"-"`

	// Selector for a Disk to populate diskId.
	// +kubebuilder:validation:Optional
	DiskIDSelector *v1.Selector `json:"diskIdSelector,omitempty" tf:"-"`

	// The Volume ID to map to this device slot.
	// The Block Storage volume ID to map to this disk slot
	// +kubebuilder:validation:Optional
	VolumeID *float64 `json:"volumeId,omitempty" tf:"volume_id,omitempty"`
}

type DevicesSdfInitParameters struct {

	// The Disk ID to map to this device slot
	// The Disk ID to map to this disk slot
	// +crossplane:generate:reference:type=Disk
	DiskID *float64 `json:"diskId,omitempty" tf:"disk_id,omitempty"`

	// Reference to a Disk to populate diskId.
	// +kubebuilder:validation:Optional
	DiskIDRef *v1.Reference `json:"diskIdRef,omitempty" tf:"-"`

	// Selector for a Disk to populate diskId.
	// +kubebuilder:validation:Optional
	DiskIDSelector *v1.Selector `json:"diskIdSelector,omitempty" tf:"-"`

	// The Volume ID to map to this device slot.
	// The Block Storage volume ID to map to this disk slot
	VolumeID *float64 `json:"volumeId,omitempty" tf:"volume_id,omitempty"`
}

type DevicesSdfObservation struct {

	// The Disk ID to map to this device slot
	// The Disk ID to map to this disk slot
	DiskID *float64 `json:"diskId,omitempty" tf:"disk_id,omitempty"`

	// The Volume ID to map to this device slot.
	// The Block Storage volume ID to map to this disk slot
	VolumeID *float64 `json:"volumeId,omitempty" tf:"volume_id,omitempty"`
}

type DevicesSdfParameters struct {

	// The Disk ID to map to this device slot
	// The Disk ID to map to this disk slot
	// +crossplane:generate:reference:type=Disk
	// +kubebuilder:validation:Optional
	DiskID *float64 `json:"diskId,omitempty" tf:"disk_id,omitempty"`

	// Reference to a Disk to populate diskId.
	// +kubebuilder:validation:Optional
	DiskIDRef *v1.Reference `json:"diskIdRef,omitempty" tf:"-"`

	// Selector for a Disk to populate diskId.
	// +kubebuilder:validation:Optional
	DiskIDSelector *v1.Selector `json:"diskIdSelector,omitempty" tf:"-"`

	// The Volume ID to map to this device slot.
	// The Block Storage volume ID to map to this disk slot
	// +kubebuilder:validation:Optional
	VolumeID *float64 `json:"volumeId,omitempty" tf:"volume_id,omitempty"`
}

type DevicesSdgInitParameters struct {

	// The Disk ID to map to this device slot
	// The Disk ID to map to this disk slot
	// +crossplane:generate:reference:type=Disk
	DiskID *float64 `json:"diskId,omitempty" tf:"disk_id,omitempty"`

	// Reference to a Disk to populate diskId.
	// +kubebuilder:validation:Optional
	DiskIDRef *v1.Reference `json:"diskIdRef,omitempty" tf:"-"`

	// Selector for a Disk to populate diskId.
	// +kubebuilder:validation:Optional
	DiskIDSelector *v1.Selector `json:"diskIdSelector,omitempty" tf:"-"`

	// The Volume ID to map to this device slot.
	// The Block Storage volume ID to map to this disk slot
	VolumeID *float64 `json:"volumeId,omitempty" tf:"volume_id,omitempty"`
}

type DevicesSdgObservation struct {

	// The Disk ID to map to this device slot
	// The Disk ID to map to this disk slot
	DiskID *float64 `json:"diskId,omitempty" tf:"disk_id,omitempty"`

	// The Volume ID to map to this device slot.
	// The Block Storage volume ID to map to this disk slot
	VolumeID *float64 `json:"volumeId,omitempty" tf:"volume_id,omitempty"`
}

type DevicesSdgParameters struct {

	// The Disk ID to map to this device slot
	// The Disk ID to map to this disk slot
	// +crossplane:generate:reference:type=Disk
	// +kubebuilder:validation:Optional
	DiskID *float64 `json:"diskId,omitempty" tf:"disk_id,omitempty"`

	// Reference to a Disk to populate diskId.
	// +kubebuilder:validation:Optional
	DiskIDRef *v1.Reference `json:"diskIdRef,omitempty" tf:"-"`

	// Selector for a Disk to populate diskId.
	// +kubebuilder:validation:Optional
	DiskIDSelector *v1.Selector `json:"diskIdSelector,omitempty" tf:"-"`

	// The Volume ID to map to this device slot.
	// The Block Storage volume ID to map to this disk slot
	// +kubebuilder:validation:Optional
	VolumeID *float64 `json:"volumeId,omitempty" tf:"volume_id,omitempty"`
}

type DevicesSdhInitParameters struct {

	// The Disk ID to map to this device slot
	// The Disk ID to map to this disk slot
	// +crossplane:generate:reference:type=Disk
	DiskID *float64 `json:"diskId,omitempty" tf:"disk_id,omitempty"`

	// Reference to a Disk to populate diskId.
	// +kubebuilder:validation:Optional
	DiskIDRef *v1.Reference `json:"diskIdRef,omitempty" tf:"-"`

	// Selector for a Disk to populate diskId.
	// +kubebuilder:validation:Optional
	DiskIDSelector *v1.Selector `json:"diskIdSelector,omitempty" tf:"-"`

	// The Volume ID to map to this device slot.
	// The Block Storage volume ID to map to this disk slot
	VolumeID *float64 `json:"volumeId,omitempty" tf:"volume_id,omitempty"`
}

type DevicesSdhObservation struct {

	// The Disk ID to map to this device slot
	// The Disk ID to map to this disk slot
	DiskID *float64 `json:"diskId,omitempty" tf:"disk_id,omitempty"`

	// The Volume ID to map to this device slot.
	// The Block Storage volume ID to map to this disk slot
	VolumeID *float64 `json:"volumeId,omitempty" tf:"volume_id,omitempty"`
}

type DevicesSdhParameters struct {

	// The Disk ID to map to this device slot
	// The Disk ID to map to this disk slot
	// +crossplane:generate:reference:type=Disk
	// +kubebuilder:validation:Optional
	DiskID *float64 `json:"diskId,omitempty" tf:"disk_id,omitempty"`

	// Reference to a Disk to populate diskId.
	// +kubebuilder:validation:Optional
	DiskIDRef *v1.Reference `json:"diskIdRef,omitempty" tf:"-"`

	// Selector for a Disk to populate diskId.
	// +kubebuilder:validation:Optional
	DiskIDSelector *v1.Selector `json:"diskIdSelector,omitempty" tf:"-"`

	// The Volume ID to map to this device slot.
	// The Block Storage volume ID to map to this disk slot
	// +kubebuilder:validation:Optional
	VolumeID *float64 `json:"volumeId,omitempty" tf:"volume_id,omitempty"`
}

// ConfigSpec defines the desired state of Config
type ConfigSpec struct {
	v1.ResourceSpec `json:",inline"`
	ForProvider     ConfigParameters_2 `json:"forProvider"`
	// THIS IS A BETA FIELD. It will be honored
	// unless the Management Policies feature flag is disabled.
	// InitProvider holds the same fields as ForProvider, with the exception
	// of Identifier and other resource reference fields. The fields that are
	// in InitProvider are merged into ForProvider when the resource is created.
	// The same fields are also added to the terraform ignore_changes hook, to
	// avoid updating them after creation. This is useful for fields that are
	// required on creation, but we do not desire to update them after creation,
	// for example because of an external controller is managing them, like an
	// autoscaler.
	InitProvider ConfigInitParameters_2 `json:"initProvider,omitempty"`
}

// ConfigStatus defines the observed state of Config.
type ConfigStatus struct {
	v1.ResourceStatus `json:",inline"`
	AtProvider        ConfigObservation_2 `json:"atProvider,omitempty"`
}

// +kubebuilder:object:root=true
// +kubebuilder:subresource:status
// +kubebuilder:storageversion

// Config is the Schema for the Configs API. Manages a Linode Instance Config.
// +kubebuilder:printcolumn:name="READY",type="string",JSONPath=".status.conditions[?(@.type=='Ready')].status"
// +kubebuilder:printcolumn:name="SYNCED",type="string",JSONPath=".status.conditions[?(@.type=='Synced')].status"
// +kubebuilder:printcolumn:name="EXTERNAL-NAME",type="string",JSONPath=".metadata.annotations.crossplane\\.io/external-name"
// +kubebuilder:printcolumn:name="AGE",type="date",JSONPath=".metadata.creationTimestamp"
// +kubebuilder:resource:scope=Cluster,categories={crossplane,managed,linode}
type Config struct {
	metav1.TypeMeta   `json:",inline"`
	metav1.ObjectMeta `json:"metadata,omitempty"`
	// +kubebuilder:validation:XValidation:rule="!('*' in self.managementPolicies || 'Create' in self.managementPolicies || 'Update' in self.managementPolicies) || has(self.forProvider.label) || (has(self.initProvider) && has(self.initProvider.label))",message="spec.forProvider.label is a required parameter"
	Spec   ConfigSpec   `json:"spec"`
	Status ConfigStatus `json:"status,omitempty"`
}

// +kubebuilder:object:root=true

// ConfigList contains a list of Configs
type ConfigList struct {
	metav1.TypeMeta `json:",inline"`
	metav1.ListMeta `json:"metadata,omitempty"`
	Items           []Config `json:"items"`
}

// Repository type metadata.
var (
	Config_Kind             = "Config"
	Config_GroupKind        = schema.GroupKind{Group: CRDGroup, Kind: Config_Kind}.String()
	Config_KindAPIVersion   = Config_Kind + "." + CRDGroupVersion.String()
	Config_GroupVersionKind = CRDGroupVersion.WithKind(Config_Kind)
)

func init() {
	SchemeBuilder.Register(&Config{}, &ConfigList{})
}
